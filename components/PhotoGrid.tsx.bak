import React, { useEffect, useRef, useMemo, useState } from "react";
import { PortfolioItem } from "../types";
import { motion } from "framer-motion";
import { PhotoCard } from "./PhotoCard";
import { useLibrary } from "../contexts/LibraryContext";
import { useSelection } from "../contexts/SelectionContext";

interface PhotoGridProps {
	items: PortfolioItem[];
	onSelect: (item: PortfolioItem) => void;
	selectionMode: boolean;
	selectedIds: Set<string>;
	onToggleSelect: (id: string) => void;
	showColorTags: boolean;
	onHover?: (item: PortfolioItem | null) => void;
	columns?: number;
	focusedId?: string | null;
	onFocusChange?: (id: string | null) => void;
	registerItemRef?: (id: string, el: HTMLElement | null) => void;
	onContextMenu?: (e: React.MouseEvent, item: PortfolioItem) => void;
	onTagClick?: (tag: string) => void;
	selectedTag?: string | null;
}

const ITEMS_PER_PAGE = 30;

export const PhotoGrid: React.FC<PhotoGridProps> = ({
	items,
	onSelect,
	selectionMode,
	selectedIds,
	onToggleSelect,
	showColorTags,
	onHover,
	columns = 4,
	focusedId,
	onFocusChange,
	registerItemRef,
	onContextMenu,
	onTagClick,
	selectedTag,
}) => {
	const containerRef = useRef<HTMLDivElement>(null);
	const observerTarget = useRef<HTMLDivElement>(null);

	// Infinite Scroll State
	const [visibleCount, setVisibleCount] = useState(ITEMS_PER_PAGE);

	// Reset count when source items change significantly (e.g. folder change)
	useEffect(() => {
		setVisibleCount(ITEMS_PER_PAGE);
		// Scroll to top when items are completely swapped out (folder change)
		if (window.scrollY > 200) {
			window.scrollTo({ top: 0, behavior: "smooth" });
		}
	}, [items.length]); // Use length as a simple proxy for change

	// Intersection Observer for Infinite Scroll
	useEffect(() => {
		const observer = new IntersectionObserver(
			(entries) => {
				const firstEntry = entries[0];
				if (firstEntry?.isIntersecting && visibleCount < items.length) {
					setVisibleCount((prev) =>
						Math.min(prev + ITEMS_PER_PAGE, items.length)
					);
				}
			},
			{ threshold: 0.1, rootMargin: "400px" } // Preload before reaching bottom
		);

		if (observerTarget.current) {
			observer.observe(observerTarget.current);
		}

		return () => {
			if (observerTarget.current) observer.unobserve(observerTarget.current);
		};
	}, [items.length, visibleCount]);

	// Slice items for display
	const displayedItems = useMemo(() => {
		return items.slice(0, visibleCount);
	}, [items, visibleCount]);

	// --- Logic: Distributed Masonry ---
	const distributedColumns = useMemo(() => {
		const cols: PortfolioItem[][] = Array.from({ length: columns }, () => []);
		displayedItems.forEach((item, index) => {
			const targetCol = cols[index % columns];
			if (targetCol) targetCol.push(item);
		});
		return cols;
	}, [displayedItems, columns]);

	// Keyboard Navigation Effect
	useEffect(() => {
		const handleKeyDown = (e: KeyboardEvent) => {
			if (!items || items.length === 0) return;
			if (
				e.target instanceof HTMLInputElement ||
				e.target instanceof HTMLTextAreaElement
			)
				return;

			// If nothing focused, focus the first one on keypress
			let currentIndex = -1;
			if (focusedId) {
				currentIndex = items.findIndex((item) => item.id === focusedId);
			}

			if (
				currentIndex === -1 &&
				["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)
			) {
				const firstItem = items[0];
				if (items.length > 0 && firstItem) {
					onFocusChange?.(firstItem.id);
				}
				return;
			}

			let nextIndex = currentIndex;

			switch (e.key) {
				case "ArrowRight":
					e.preventDefault();
					nextIndex = Math.min(items.length - 1, currentIndex + 1);
					break;
				case "ArrowLeft":
					e.preventDefault();
					nextIndex = Math.max(0, currentIndex - 1);
					break;
				case "ArrowUp":
					e.preventDefault();
					nextIndex = Math.max(0, currentIndex - columns);
					break;
				case "ArrowDown":
					e.preventDefault();
					nextIndex = Math.min(items.length - 1, currentIndex + columns);
					break;
				case " ":
					e.preventDefault();
					if (currentIndex !== -1) {
						const currentItem = items[currentIndex];
						if (currentItem) {
							onSelect(currentItem);
						}
					}
					break;
				default:
					return;
			}

			if (nextIndex !== currentIndex && items[nextIndex]) {
				const nextItem = items[nextIndex];
				if (nextItem) {
					onFocusChange?.(nextItem.id);

					// Auto-scroll logic needs to check if item is in DOM (rendered)
					// If the item is outside the visible range (virtualized), we might need to force load more
					// For simplicity in this implementation, infinite scroll handles "down",
					// but "jumping" way ahead is tricky.
					if (nextIndex >= visibleCount) {
						setVisibleCount((prev) => nextIndex + ITEMS_PER_PAGE);
					}

					setTimeout(() => {
						const nextItem = items[nextIndex];
						if (nextItem) {
							const element = document.getElementById(
								`grid-item-${nextItem.id}`
							);
							element?.scrollIntoView({ behavior: "smooth", block: "nearest" });
						}
					}, 50);
				}
			}
		};

		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [items, focusedId, columns, onFocusChange, onSelect, visibleCount]);

	return (
		<div
			className="p-4 sm:p-8 pb-10 pt-(--layout-pt) w-full min-h-screen"
			ref={containerRef}
		>
			{/* Flex container holding the columns */}
			<div className="flex gap-4 items-start w-full">
				{distributedColumns.map((colItems, colIndex) => (
					<div key={colIndex} className="flex flex-col gap-4 flex-1 min-w-0">
						{colItems.map((item) => {
							const isSelected = selectedIds.has(item.id);
							const isFocused = focusedId === item.id;

							return (
								<PhotoCard
									key={item.id}
									item={item}
									isSelected={isSelected}
									isFocused={isFocused}
									selectionMode={selectionMode}
									showColorTags={showColorTags}
									onSelect={onSelect}
									onToggleSelect={onToggleSelect}
									onFocus={(id) => onFocusChange?.(id)}
									onContextMenu={onContextMenu || (() => {})}
									onHover={onHover || (() => {})}
									registerItemRef={registerItemRef}
									onTagClick={onTagClick}
									selectedTag={selectedTag}
								/>
							);
						})}
					</div>
				))}
			</div>

			{/* Sentinel for Infinite Scroll */}
			<div
				ref={observerTarget}
				className="w-full h-20 flex items-center justify-center text-white/20"
			>
				{visibleCount < items.length && (
					<div className="animate-pulse">Loading more...</div>
				)}
			</div>
		</div>
	);
};
